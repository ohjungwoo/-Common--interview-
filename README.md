https://cdn.clien.net/web/api/file/F01/7662770/c789b94426266.jpg?w=780&h=30000&gif=true

##########################################################
프로그래머 면접 질문
##########################################################



1. 객체지향프로그래밍(Object-orinted Programming)이란 ?

데이터를 객체로 취급하여 프로그램에 반영한 것이며, 순차적으로 프로그램이 동작하는 기존의 것들과는 다르게 객체의 상호작용을 통해 프로그램이 동작하는 것을 말합니다.

캡슐화, 다형성, 상속 을 이용하여 코드 재사용을 증가시키고, 유지보수를 감소시키는 장점을 얻기 위해서 객체들을 연결 시켜 프로그래밍 하는 것 입니다.



2. 클래스(Class)란 ?

객체를 정의해 놓은것이며 객체는 클래스를 바탕으로 만들어진 사물입니다. 다시말하면 클래스는 객체를 만들기위한 설계도이며 객체는 그 설계도를 보고 만들어진 사물이라고 이라고 생각하시면됩니다. 



3. 인스턴스(Instance) ?

클래스로부터 객체를 만드는 과정을 인스턴스화 라고하며 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 합니다.



4. 객체(Object)

Object(객체)는 OOP에서 데이터(변수)와 그 데이터에 관련되는 동작(함수). 즉 절차, 방법, 기능을 모두 포함한 개념입니다.



5. 오버로딩(Overloading)과 오버라이딩(Overriding)의 차이점

오버로딩(Overloading)

- 같은 이름의 메소드를 여러개 정의하는 것

- 매개변수의 타입이 다르거나 개수가 달라야 한다.

* return type과 접근 제어자는 영향을 주지 않음.



Overriding(오버라이딩)

- 상속에서 나온 개념

- 상위 클래스(부모 클래스)의 메소드를 하위 클래스(자식 클래스)에서 재정의



6. Servlet, JSP

Servlet Container가 이해할 수 있게 구성된 Java 소스에 HTML 코드가 삽입된다. 
JSP는 반대로 HTML코드에 Java코드가 삽입된다. 
Servlet class는 컴파일과정과 등록 과정이 필요하지 하지만 JSP는 필요 없다. 
Servlet 보다는 JSP 디자인과 로직에 대한 구분이 명확해서 유지보수가 용이하다.
간단한 로직을 구현할 때는 JSP가 더 간편하다. 하지만 복잡한 로직을 구현할 때에 HTML 중심의 코드가 이해하기 어렵게 만들수 있고, 프로그래밍 언어를 모르는 사람이 실수로 중요한 코드를 건들 우려도 있다. 그리고 힘들게 개발한 로직의 유출을 막기 위해서도 Servlet 기술이 필요하게 된다. => 그래서 요즘은 JSP 기술과 Servlet 기술을 혼용한 새로운 프로그래밍 방법이 권장되고 있다. 프로그램의 기능을 구현하는 복잡한 로직은 서블릿 클래스 안에 기술하고, 그 결과를 가져다가 출력하는 일만 JSP 페이지가 담당하도록 만드는 방법이다.
7. JDBC(Java Data Base Connection)

JAVA를 통해 데이터 베이스에 접근 할 수 있는 프로그래밍을 의미합니다.



8. Get과 Post 방식

Get 방식

- 클라이언트에서 서버로 데이터를 전달할 때, 주소 뒤에 "이름"과 "값"이 결합된 스트링 형태로 전달

- 주소창에 쿼리 스트링이 그대로 보여지기 때문에 보안성이 떨어진다.

- 길이에 제한이 있다.(=전송 데이터의 한계가 있다.)

- Post방식보다 상대적으로 전송 속도가 빠르다.



Post 방식

- 일정 크기 이상의 데이터를 보내야 할 때 사용한다.

- 서버로 보내기 전에 인코딩하고, 전송 후 서버에서는 다시 디코딩 작업을 한다.

- 주소창에 전송하는 데이터의 정보가 노출되지 않아 Get방식에 비해 보안성이 높다.

- 속도가 Get방식보다 느리다.

- 쿼리스트링(문자열) 데이터 뿐만 아니라, 라디오 버튼, 텍스트 박스 같은 객체들의 값도 전송가능.



Get과 Post 차이점

- Get은 주로 웹 브라우저가 웹 서버에 데이터를 요청할 때 사용

- Post는 웹 브라우저가 웹 서버에 데이터를 전달하기 위해 사용.

- Get을 사용하면 웹 브라우저에서 웹 서버로 전달되는 데이터가 인코딩되어 URL에 붙는다.

- Post방식은 전달되는 데이터가 보이지 않는다.

- Get방식은 전달되는 데이터가 255개의 문자를 초과하면 문제가 발생할 수 있다.

- 웹서버에 많은 데이터를 전달하기 위해서는 Post 방식을 사용하는 것이 바람직하다.



9. Session과 Cookie

Session과 Cookie 사용 이유

- 현재 우리가 인터넷에서 사용하고 있는 HTTP프로토콜은 연결 지향적인 성격을 버렸기 때문에 새로운 페이지를 요청할 때마다

 새로운 접속이 이루어지며 이전 페이지와 현재 페이지 간의 관계가 지속되지 않는다. 이에 따라 HTTP프로토콜을 이용하게 되는 

 웹사이트에서는 웹페이지에 특정 방문자가 머무르고 있는 동안에 그 방문자의 상태를 지속시키기 위해 쿠키와 세션을 이용한다.



Session

- 특정 웹사이트에서 사용자가 머무르는 기간 또는 한 명의 사용자의 한번의 방문을 의미한다.

- Session에 관련된 데이터는 Server에 저장된다.

- 웹 브라우저의 캐시에 저장되어 브라우저가 닫히거나 서버에서 삭제시 사라진다.

- Cookie에 비해 보안성이 좋다.



Cookie

- 사용자 정보를 유지할 수 없다는 HTTP의 한계를 극복할 수 있는 방법

- 인터넷 웹 사이트의 방문 기록을 남겨 사용자와 웹 사이트 사이를 매개해 주는 정보이다.

- Cookie는 인터넷 사용자가 특정 웹서버에 접속할 때, 생성되는 개인 아이디와 비밀번호, 방문한 사이트의 정보를 담은 임시 파일로써,

  Server가 아닌 Client에 텍스트 파일로 저장되어 다음에 해당 웹서버를 찾을 경우 웹서버에서는 그가 누구인지 어떤 정보를 주로 찾았는지 등을 파악할 때 사용된다.

- Cookie는 Client PC에 저장되는 정보기 때문에, 다른 사용자에 의해서 임의로 변경이 가능하다.(정보 유출 가능, Session보다 보안성이 낮은 이유)



Q. 보안성이 낮은 Cookie 대신 Session을 사용하면 되는데 안하는 이유?

A. 모든 정보를 Session에 저장하면 Server의 메모리를 과도하게 사용하게 되어 Server에 무리가 감



10. MVC 패턴

 객체지향프로그래밍에서, MVC란 사용자 인터페이스를 성공적이며 효과적으로 데이터 모형에 관련 시키기 위한 방법론 또는 설계 방식중 하나이다.

 MVC 패턴은 목적 코드의 재사용에 유용한 것은 물론, 사용자 인터페이스와 응용프로그램 개발에 소요되는 시간을 현저하게 줄여주는 형식이라고 많은 개발자들이 평가하고 있다.



MVC 구성요소

Model - 소프트웨어 응용과 그와 관련된 고급 클래스 내의 논리적 데이터 기반 구조를 표현. 이 목적 모형은 사용자 인터페이스에 관한 어떠한 정보도 가지고 있지 않다.

View - 사용자 인터페이스 내의 구성요소들을 표현(사용자에게 보여지는 화면)

Controller - Model과 View를 연결하고 있는 클래스를 대표, Model과 View 내의 클래스들 간 정보 교환하는데 사용.



11. Interface, Abstract

Interface

- 일종의 추상 클래스

- 오직 추상메서드와 상수만을 멤버로 갖는다.

- Implements 키워드를 사용

- 상속의 관계가 없는 클래스간 서로 공통되는 로직을 구현하여 쓸 수 있도록한다.

- Extends는 하나의 클래스만 상속 가능하나 Interface는 다중 상속이 가능하다.

Abstract

- 추상메서드를 하나 이상 가진 클래스

- 자신의 생성자로 객체 생성 불가능

- 하위 클래스를 참조하여 상위 클래스의 객체를 생성

- 하위 클래스를 제어하기 위해 사용



Abstract vs Interface

추상 클래스(Abstract)

클래스를 설계도에 비유한다면 추상클래스는 미완성 설계도에 비유할 수 있다. 미완성 설계도란, 단어

의 뜻 그대로 완성되지 못한 채로 남겨진 설계도를 말한다. 클래스가 미완성이라는 것은 멤버의 개수에

관계된 것이 아니라, 단지 미완성 메서드(추상메서드)들 포함하고 있다는 의미이다. 미완성 설계도로

완성된 제품을 만들 수 없듯이 추상클래스로 인스턴스는 생성활 수 없다. 추상클래스는 상속을 통해서

자손클래스에 의해서만 완성될 수 있다.

**자바의 정석 참고**

인터페이스 (Interface)

인터페이스는 일종의 추상클래스이다. 인터페이스는 추상클래스처럼 추상메서드를 갖지만 추상클래스 보다 추상화 정도가 높아서 추상클래스와는 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으 로 가질 수 없다. 오직 추상메서드와 상수만을 멤버로 가질 수 있으며, 그 외의 어떠한 요소도 허용하지 않는다. 추상클래스를 부분적으로만 완성된 '미완성 설계도'라고 한다면, 인터페이스는 구현된 것은 아 무것도 없고 밑그림만 그려져 있는 '기본 설계도'라고 할 수 있다. 인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와는 달리 다중상속, 즉 여러개의 인터페이스로부터 상속을 받는 것이 가능 하다.

**자바의 정석 참고**







[출처] java 개발자 면접 예상 질문|작성자 Hanjoong



공통점 

- new 연산자로 인스턴스 생성 불가능.

- 프로토타입만 있는 메서드를 갖는다.

- 사용하기 위해서는 하위클래스에서 확장/구현 해야 한다.

차이점

- 사용하는 키워드가 다르다.

- Abstract는 일반 메서드를 사용할 수 있지만, Interface는 메서드 선언만 가능하다.





12. Call by Reference, Call by Value

Call by Reference - 매개 변수의 원래 주소에 값을 저장하는 방식. 클래스 객체를 인수로 전달한 경우

Call by Value - 인수로 기본 데이터형을 사용. 주어진 값을 복사하여 처리하는 방식. 메서드 내의 처리 결과는 메서드 밖의 변수에 영향을 미치지 않는다.



13. Static의 의미 

- 클래스가 로딩될 때, 메모리 공간을 할당하는데 처음 설정된 메모리 공간이 변하지 않음을 의미

- 객체를 아무리 많이 만들어도 해당 변수는 하나만 존재(객체와 무관한 키워드)



14. Framework

- 특정 형태의 소프트웨어 문제를 해결하기 위해 상호 협력하는 클래스프레임과 인터페이스 프레임의 집합

- 특정한 틀을 만들어놓고 거기에 살을 붙여 놓음으로써 프로그램을 만들어 작업시간을 줄여주는 것이다. 

  스켈레톤 코드라고도 하는데, 뼈대가 이미 만들어져 있어서 거기에 살(기능)만, 덧붙이면 완성이 되도록 공통된 함수 또는 클래스를 미리 만들어 놓는 것을 이야기한다.

- 프레임워크는 특정 개념들의 추상화를 제공하는 여러 클래스나 컴포넌트로 구성된다.

- 프레임워크는 이렇게 추상적인 개념들이 문제를 해결하기 위해 같이 작업하는 방법을 정의한다.

- 프레임워크 컴포넌트 들은 재사용이 가능하다.

- 프레임워크는 좀 더 높은 수준에서 패턴을 조작한다.

* 프레임워크가 중요한 이유는 객체지향 개발을 하게 되면서 개발자의 취향에 따라 다양한 프로그램이 나오게 되었다.

 프로그램 개발에 투입되는 개발자도 점점 늘어남에 따라 전체 시스템의 통합성, 일관성이 부족하게 되었기 때문이다. 

 그래서 개발자의 자유를 제한하기 위해 프레임워크를 도입했다.

프레임워크가 가져야할 특징

a. 개발자들이 따라야할 가이드라인을 가진다.

b. 개발할 수 있는 범위가 정해져 있다.

c. 개발자를 위한 다양한 도구들이 지원된다.

프레임워크의 장/단점

장점 - 개발 시간을 줄일 수 있고 오류로부터 자유로울 수 있다.

단점 - 프레임워크에 너무 의존하면 개발 능력이 떨어져서 프레임워크 없이 개발하는 것이 불가능해지는 점이다.





15. Garbage Collection(가비지 컬렉션)

시스템에서 더이상 사용하지 않는 동적 할당된 메로리 블럭을 찾아 자동으로 다시 사용 가능한 자원으로 회수하는 것으로 

시스템에서 가비지컬렉션을 수행하는 부분을 가비지 컬렉터라 부른다.



16. Primitive type과 Reference type

Primitive type - 변수에 값 자체를 저장 

정수형 byte, short, int, long

실수형 float, double

문자형 char

논리형 boolean

* Primitive type은 Wrapper Class를 통해 객체로 변형할 수 있다.

예) int→Integer, char→Character(int와 char를 제외한 Primitive type의 다른 자료형들은 맨 앞 알파벳을 대문자로 바꿔주면 된다. float→Float)

Reference type - 메모리상에 객체가 있는 위치를 저장

종류 - Class, Interface, Array 등



17. Wrapper Class

Primitive type으로 표현할 수 있는 간단한 데이터를 객체로 만들어야 할 경우가 있는데 그러한 기능을 지원하는 클래스



18. Spring Framework(스프링 프레임워크)

자바(JAVA) 플랫폼을 위한 오픈소스(Open Source) 애플리케이션 프레임워크(Framework)

자바 엔터프라이즈 개발을 편하게 해주는 오픈 소스 경량급 애플리케이션 프레임워크

자바 개발을 위한 프레임워크로 종속 객체를 생성해주고,  조립해주는 도구

자바로 된 프레임워크로 자바SE로 된 자바 객체(POJO)를 자바EE에 의존적이지 않게 연결해주는 역할

스프링 특징 간단히

- 크기와 부하의 측면에서 경량.

- 제어 역행(IoC)이라는 기술을 통해 애플리케이션의 느슨한 결합을 도모

- 관점지향 프로그래밍(AOP)을 위한 풍부한 지원

- 애플리케이션 객체의 생명 주기와 설정을 포함하고 관리한다는 점에서 일종의 컨테이너(Container)라고 할 수 있음

- 간단한 컴포넌트로 복잡한 애플리케이션을 구성하고 설정할 수 있음

스프링 특징 자세히

a. 경량 컨테이너로서 자바 객체를 직접 관리.

   각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다.

b. 스프링은 POJO(Plain Old Java Object) 방식의 프레임워크.

   일반적인 J2EE 프레임워크에 비해 구현을 위해 특정한 인터페이스를 구현하거나 상속을 받을 필요가 없어 기존에 

   존재하는 라이브러리 등을 지원하기에 용이하고 객체가 가볍다.

c. 스프링은 제어의 역행(IoC : Inversion of Control)을 지원.

   컨트롤의 제어권이 사용자가 아니라 프레임워크에 있어서 필요에 따라 스프링에서 사용자의 코드를 호출한다.

d. 스프링은 의존성 주입(DI : Dependency Injection)을 지원

   각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.

e. 스프링은 관점 지향 프로그래밍(AOP : Aspect-Oriented Programming)을 지원

   따라서 트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.

f. 스프링은 영속성과 관련된 다양한 서비스를 지원

   iBatis나 Hibernate 등 이미 완성도가 높은 데이터베이스 처리 라이브러리와 연결할 수 있는 인터페이스를 제공한다.

g. 스프링은 확장성이 높음.

   스프링 프레임워크에 통합하기 위해 간단하게 기존 라이브러리를 감싸는 정도로 스프링에서 사용이 가능하기 때문에 수많은 라이브러리가 

   이미 스프링에서 지원되고 있고 스프링에서 사용되는 라이브러리를 별도로 분리하기도 용이하다.



19. Thread

Thread(쓰레드) - 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들을 대부분 공유하면서 실행된다, 프로세스내에서 동시에 실행되는 독립적인 실행 단위를 말함, 장점으로는 자원을 많이 사용하지 않고 구현이 쉬우며 범용성이 높다

Process(프로세스) - 메인 메모리에서 실행중인 프로그램 또는 운영체제에서 실행중인 하나의 프로그램(하나 이상의 쓰레드를 포함한다.)

Thread 장점

- 빠른 프로세스 생성

- 적은 메모리 사용

- 쉬운 정보 공유

Thread 단점

- 교착상태에 빠질 수 있다.

* 교착상태 - 다중프로그래밍 체제에서 하나 또는 그 이상의 프로세스가 수행 할 수 없는 어떤 특정시간을 기다리고 있는 상태.

Thread와 Process 차이

여러 분야에서 '과정' 또는 '처리'라는 뜻으로 사용되는 용어로 컴퓨터 분야에서는 '실행중인 프로그램'이라는 뜻으로 쓰인다. 

이 프로세스 내에서 실행되는 각각의 일을 스레드라고 한다. 프로세스 내에서 실행되는 세부 작업 단위로 여러 개의 스레드가 하나의 프로세스를 이루게 되는 것이다.



20. 접근제한자(public > protected > default > private)

public - 같은 프로젝트 어디서든지 사용할 수 있다.

protected - 같은 패키지 내, 다른 패키지에서 상속받아 자손클래스에서 접근 가능하다. 

default - 같은 패키지 내에서만 접근 가능하다.

private - 같은 클래스 내에서만 접근 가능하다.



21. TCP(Transmission Control Protocol) UDP(User Datagram Protocol)의 차이점

TCP

- 연결형 서비스 제공

- 높은 신뢰성 보장

- 연결의 설정(3-way handshaking)

- 연결의 해제(4-way handshaking)

- 데이터 흐름 제어, 혼잡 제어

- 전이중, 점대점 서비스(양방향 송수신 서비스)

- 양방향통신



UDP

- 비연결형 서비스 제공

- 신뢰성이 낮음

- 데이터의 전송 순서가 바뀔 수 있음

- 데이터 수신 여부 확인 안함(3-way handshaking과 같은 과정 X)

- TCP보다 전송속도가 빠름

- 단방향 통신



http://ddiri01.tistory.com/28 님이 정리한 글을 옮깁니다.

- TCP 통신 

 TCP(Transmission Control Protocol)는 인터넷에서 가장 흔하게 그리고 많이 쓰이는 프로토콜 방식이다. 그 이유는 TCP통신은 error correction이라는게 존재하는데 말 그대로 에러를 다시 잡아주는 것이다. 서버에서 클라이언트에게 어떤 정보를 보냈다고 하자! 그러면 클라이언트는 서버가 보낸 정보를 제대로 받았는지, 확인해주는 메세지를 다시 서버에게 돌려주고, 클라이언트가 제대로 받지 못했을 경우엔 resend를 서버에 요청 할 수 있다. 그러면 loss된 데이터를 다시 클라이언트에게 보낼 수 있는 것이다. 이런 방법들을 flow control이라고 하며, 오리지널 데이터를 로스 하지 않고 받을 수 있게 한다. 즉, guaranteed delivery!

 - UDP 통신 

 UDP(User Datagram Protocol) 은 인터넷에서 또 많이 쓰이는 프로토콜인데 그 사용처는 tcp 통신과는 다르다. tcp통신과의 가장 큰 차이는 단방향 통신이라는것! 서버가 클라이언트에게 혹은 클라이언트가 서버에게! error correction이 없고, 무조건 보내는 쪽에선 던지기만 하고 받는 쪽에선 받기만 한다. 그러다가 데이터 로스가 중간에서 발생하면 어쩌냐? 무시한다. 그냥 던지고 받는거다 ! 이렇게 되면 장점은 TCP통신 보다는 훨씬 빠른 전송을 보여주게 된다.



22. Singleton Design Patter(싱글톤 디자인 패턴, 싱글톤 패턴)

클래스 인스턴스가 여러개 생성될 필요 없다면, 하나만 만들어지도록 하고 인스턴스에 대한 전역 접근을 제공하는 기법이다.



23. Database에서 Index란?

인덱스는 데이터베이스 분야에 있어서 테이블에 대한 동작의 속도를 높여주는 자료 구조를 일컫는다.

인덱스는 테이블 내의 1개의 컬럼, 혹은 여러 개의 컬럼을 이용하여 생성될 수 있다.

고속의 검색 동작뿐만 아니라 레코드 접근과 관련 효율적인 순서 매김 동작에 대한 기초를 제공한다.

인덱스를 저장하는 데 필요한 디스크 공간은 보통 테이블을 저장하는 데 필요한 디스크 공간보다 작다.



데이터베이스에서 테이블과 클러스터에 연관되어 독립적인 저장 공간을 보유하고 있는 객체(object)이다. 

사용자는 데이터베이스에 저장된 자료를 더욱 빠르게 조회하기 위하여 인덱스를 생성하고 사용한다. 



DB에서 자료를 검색하는 두 가지 방법

FTS(Full Table Scan) : 테이블을 처음 부터 끝까지 검색하는 방법

Index Scan : 인덱스를 검색하여 해당 자료의 테이블을 액세스 하는 방법.



출처: http://ktko.tistory.com/entry/프로그래머-면접-질문?category=625364 [KTKO 개발 블로그와 여행 일기]







##########################################################
개발자 면접 질문(자바, 스프링)
##########################################################


약 1개월 전 by 개발자 ktko
OOP란 ?



데이터를 객체로 취급하여 프로그램에 반영한 것이며, 순차적으로 프로그램이 동작하는 기존의 것들과는 다르게 객체의 상호작용을 통해 프로그램이 동작하는 것을 말합니다. 캡슐화, 다형성, 상속 을 이용하여 코드 재사용을 증가시키고, 유지보수를 감소시키는 장점을 얻기 위해서 객체들을 연결 시켜 프로그래밍 하는 것 입니다.



자바의 메모리 영역(간단하게 설명)



1. 메서드 영역 : static 변수, 전역변수, 코드에서 사용되는 Class 정보 등이 올라간다.코드에서 사용되는 class들을 로더로 읽어 클래스별로 런타임 필드데이터, 메서드 데이터 등을 분류해 저장한다.

2. 스택(Stack) : 지역변수, 함수(메서드) 등이 할당되는 LIFO(Last In First Out) 방식의 메모리

3. 힙(Heap) : new 연산자를 통한 동작할당된 객체들이 저장되며, 가비지 컬렉션에 의해 메모리가 관리되어 진다.

 

인터페이스(Interface)란? 또 왜 사용하나?

인터페이스는 모든 메서드가 구현부가 없는 추상메서드로 이루어진 클래스로, abstract 키워드를 붙이지 않아도 자동으로 모든 메서드는 추상메서드로

정의가 된다. 또한 변수도 자동으로 final static 키워드가 붙게 된다.

 

– 메모리 상수풀 영역 이란

힙영역(프로그래머가 관리하는 메모리 영역)에 생성되어 자바 프로세스 종료까지 계속 유지되는 메모리영역입니다. 기본적으로 JVM에서 관리하며 프로그래머가 작성한 상수에 대해 최우선적으로 찾아보고 없으면 상수풀에 추가한 이후 그 주소값을 리턴합니다. 그로 인해 메모리 절약 효가가 있습니다.



왜 인터페이스를 사용하는가? 



팀작업시 개발코드 부분과 객체가 서로 통신하는 접점 역할을 지원하게 되는데, 이는 개발코드에선 객체의 내부 구조를 모르더라도 인터페이스의

메서드 명만 알고 있으면 되기 때문이다. 이를 통해 얻을 수 있는 장점은 해당 메서드를 통해 나오는 결과물을 알고 있기 때문에 다른 팀의

작업을 기다리고 있지 않아도 되며, 또한 해당 객체가 수정될 경우 개발 코드 부분은 수정을 하지 않아도 된다.

또한, 부가적으로 객체를 파일에 쓰기 위해 Serializable 인터페이스를 구현하거나, Collections.sort()를 하기 위해서 Comparable 인터페이스를 

상속하는 것, Cloneable 을 구현하는 것처럼 특정 작업을 하겠다라는 "Mark"역할을 해주기도 한다.



jdbc란 무엇인가



자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API이다. JDBC는 데이터베이스에서 자료를 쿼리하거나 업데이트하는 방법을 제공한다.



직렬화란 무엇인가



자바에서 입출력에 사용되는 것은 스트림이라는 데이터 통로를 통해 이동했습니다. 하지만 객체는 바이트형이 아니라서 스트림을 통해 파일에 저장하거나 네트워크로 전송할 수 없습니다. 따라서 객체를 스트림을 통해 입출력하려면 바이트 배열로 변환하는 것이 필요한데, 이를 '직렬화' 라고 합니다. 반대로 스트림을 통해 받은 직렬화된 객체를 원래 모양으로 만드는 과정을 역직렬화라고 합니다.



serialVersionUID를 선언해야 하는 이유



자바가상기계 (JVM)은 직렬화와 역직렬화를 하는 시점의 클래스에 대한 버전 번호를 부여합니다. 만약 그 시점에 클래스의 정의가 바뀌어 있다면 새로운 버전 번호를 할당합니다. 그래서 직렬화할 때의 버전 번호와 역직렬화를 할 때의 버전 번호가 다르면 역직렬화가 불가능하게 될 수도 있습니다. 이런 문제를 해결하기 위해 SerialVerionUID를 사용합니다.

간단명료하게 serialVersionUID값을 저장할 때 클래스 버전이 맞는지 확인하기 위한 용도입니다.

만약 직렬화할 때 사용한 serialVersionUID의 값과 역직렬화 하기 위해 사용했던 serialVersionUID값이 다르다면 InvalidClassException이 발생할 수 있습니다.



리플렉션이란 무엇인가요



리플렉션은 컴파일러를 무시하고 런타임 상황에서 메모리에 올라간 클래스나 메서드등의 정의를 동적으로 찾아서 조작할 수 있는 일련의 행위를 말합니다. 즉 동적인 언어의 특징이라 말 할 수 있습니다. 프레임워크에서 유연성이 있는 동작을 위해 자주 사용하기도 합니다.



자바의 클래스 멤버 변수 초기화 순서에 대해서 설명하라.



1. static 변수 선언부 : 클래스가 로드 될 때 (메모리 모델상 Methd area 에 올라감) 변수가 제일 먼저 초기화 됨



2. 필드 변수 선언부 : 객체 생성 될 때 (메모리 모델상 Heap area에 올라감) 생성자 block 보다 앞서 초기화 함



3. 생성자 block : 객체 생성 될 때 (메모리 모델상 Heap area에 올라감)

JVM이 내부적으로 locking (thread safe 영역임)

필드 변수 중 final 변수의 가시화는 (다른 스레드에 공개하는 시점은) 생성자 block이 끝난 다음.

필드 변수 선언부에서 이미 초기화 되었다면 그 값들은 덮어 씀



초기화 시점

    * 클래스변수의 초기화시점 : 클래스가 처음 로딩될 때 단 한번 초기화 된다. 

    * 인스턴스변수의 초기화시점 : 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다.



초기화 순서

    * 클래스변수의 초기화순서 : 기본값 -> 명시적초기화 -> 클래스 초기화 블럭 

    * 인스턴스변수의 초기화순서 : 기본값 -> 명시적초기화 -> 인스턴스 초기화 블럭 -> 생성자



Servlet vs JSP



- Servlet : 자바 언어로 웹 개발을 위해 만들어진 것으로, Container가 이해할 수 있게 구성된 순수 자바코드로만 이루어진 것

- JSP : html 기반에 JAVA 코드를 블록화하여 삽입한 것으로 Servlet을 좀 더 쉽게 접근할 수 있도록 만들어 진 것



제너릭



클래스를 선언할 때 타입을 결정하지 않고 객체를 생성할 때 유동적인 타입으로 재사용하기 위한 것

형변환을 할 필요없고, 타입 에러가 발생할 확률이 없어진다. 



타입추론은 메서드를 호출하는 코드에서 타입인자가 정의한대로 제대로 쓰였는지 살펴보는 컴파일러의 능력이다. 



컬렉션(collection) 클래스에서 제네릭을 사용하는 이유를 설명하시오.



컬렉션 클래스에서 제네릭을 사용하면 컴파일러는 특정 타입만 포함 될 수 있도록 컬렉션을 제한합니다. 

컬렉션 클래스에 저장하는 인스턴스 타입을 제한하여 런타임에 발생할 수 있는 잠재적인 모든 예외를 컴파일타임에 잡아낼 수 있도록 도와줍니다.



pojo란 무엇인가



Plain Old Java Object. 간단히 포조 라는 말 그대로 해석하며 ㄴ오래된 방식의 자바 오브젝트로서 J2EE등의 중량 프레임워크들을 사용하면서 해당 프레임워크에 종석된 무거운 객체를 만들게 된 것에 반발하여 특정 자바 모델이나 기능, 프레임워크 등을 따르지 않는 자바 오브젝트를 지칭하는 말로 사용되었다.



박싱과 언박싱에 대해서 설명해 보세요.



원시형 -> Wrapper Class로 변환 박싱

Wrapper Class -> 원시형으로 변환 언박싱

여기에 명시적, 묵시적으로 변하는 것을 설명하면 좋을 것 같음.



'데드락’ 이란 무엇이고 이를 해결하기 위한 방법을 설명해 보시오



데드락이란, 둘 이상의 쓰레드가 lock 을 획득하기 위해 기다리는데, 이 lock 을 잡고 있는 쓰레드도 똑같이 다른 lock 을 기다리며 서로 블록 상태에 놓이는 것을 말한다. 데드락은 다수의 쓰레드가 같은 lock 을, 동시에, 다른 명령에 의해, 획득하려 할 때 발생할 수 있다.

- 자원 유형에 따라 우선 순위를 선정하여 자원을 선점하게 한다.

- 공유 불가능한 즉 상호 배제의 조건을 제거한다.



상속과 합성(컴포지션)의 차이에 대해서 설명해 주세요.  

상속은 is a 관계 

컴포지션은 개체들 간에 has a 관계이다. 



상속은 클래스를 확장하여 부모 클래스에서 속성 및 동작을 상속하는 기능입니다. 

자동차는 자동차다.

class Engine{}

abstract class Automobile{}



class car extends Automobile{

	private Engine engine;

}



합성은 클래스가 구성원 데이터로 다른 클래스의 객체를 포함 할 수있는 능력입니다. 

자동차는 엔진이 포함되어 있다.



JVM 의 역할은 무엇인지 설명해 보세요. 



JVM(Java virtual machine)은 자바를 실행하기 위한 가상 기계라고 할 수 있습니다. 여기서 가상 기계란 말이 어색하다면 프로그램을 실행하기 위해 물리적 머신과 유사한 머신을 소프트웨어로 구현한 것이라고 해석할 수 있습니다. 

JVM은 Java Byte Code를 OS에 맞게 해석해주는 역활을 합니다. Java Compiler가 *.java 파일을 컴피알을 하면 .class라는 java byte code로 변환시켜 주며, Byte Code는 기계어가 아니기 때문에 OS에서 바로 실행이 되지 않습니다. 이 때 JVM이 OS가 이해할 수 있도록 해석해줍니다



Interface VS abstract



Interface

- 일종의 추상 클래스
- 오직 추상메서드와 상수만을 멤버로 갖는다.
- Implements 키워드를 사용
- 상속의 관계가 없는 클래스간 서로 공통되는 로직을 구현하여 쓸 수 있도록한다.
- Extends는 하나의 클래스만 상속 가능하나 Interface는 다중 상속이 가능하다.

Abstract
- 추상메서드를 하나 이상 가진 클래스
- 자신의 생성자로 객체 생성 불가능
- 하위 클래스를 참조하여 상위 클래스의 객체를 생성
- 하위 클래스를 제어하기 위해 사용



다형성(폴리모피즘, Polymorphism)에 대해서 설명 하여라



다형성이란 하나의 메소드나 클래스가 있을 때 이것들이 다양한 방법으로 동작하는 것을 의미한다.




스프링의 MVC에 대해서 설명하시오.




- 객체지향프로그래밍에서, MVC란 사용자 인터페이스를 성공적이며 효과적으로 데이터 모형에 관련 시키기 위한 방법론 또는 설계 방식중 하나이다. MVC방식은 자바, Smalltalk,

- MVC 패턴은 목적 코드의 재사용에 유용한 것은 물론, 사용자 인터페이스와 응용프로그램 개발에 소요되는 시간을 현저하게 줄여주는 형식이라고 많은 개발자들이 평가하고 있다.

MVC 구성요소

Model - 소프트웨어 응용과 그와 관련된 고급 클래스 내의 논리적 데이터 기반 구조를 표현. 이 목적 모형은 사용자 인터페이스에 관한 어떠한 정보도 가지고 있지 않다.

View - 사용자 인터페이스 내의 구성요소들을 표현(사용자에게 보여지는 화면)

Controller - Model과 View를 연결하고 있는 클래스를 대표, Model과 View 내의 클래스들 간 정보 교환하는데 사용.

Spring Framework(스프링 프레임워크)

자바(JAVA) 플랫폼을 위한 오픈소스(Open Source) 애플리케이션 프레임워크(Framework)

자바 엔터프라이즈 개발을 편하게 해주는 오픈 소스 경량급 애플리케이션 프레임워크

자바 개발을 위한 프레임워크로 종속 객체를 생성해주고,  조립해주는 도구

 

자바로 된 프레임워크로 자바SE로 된 자바 객체(POJO)를 자바EE에 의존적이지 않게 연결해주는 역할

스프링 특징 간단히

- 크기와 부하의 측면에서 경량.

- 제어 역행(IoC)이라는 기술을 통해 애플리케이션의 느슨한 결합을 도모

- 관점지향 프로그래밍(AOP)을 위한 풍부한 지원

- 애플리케이션 객체의 생명 주기와 설정을 포함하고 관리한다는 점에서 일종의 컨테이너(Container)라고 할 수 있음

- 간단한 컴포넌트로 복잡한 애플리케이션을 구성하고 설정할 수 있음


스프링 특징 자세히

 a. 경량 컨테이너로서 자바 객체를 직접 관리.

   각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다.

b. 스프링은 POJO(Plain Old Java Object) 방식의 프레임워크.

   일반적인 J2EE 프레임워크에 비해 구현을 위해 특정한 인터페이스를 구현하거나 상속을 받을 필요가 없어 기존에 

   존재하는 라이브러리 등을 지원하기에 용이하고 객체가 가볍다.

c. 스프링은 제어의 역행(IoC : Inversion of Control)을 지원.

   컨트롤의 제어권이 사용자가 아니라 프레임워크에 있어서 필요에 따라 스프링에서 사용자의 코드를 호출한다.

d. 스프링은 의존성 주입(DI : Dependency Injection)을 지원

   각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.

e. 스프링은 관점 지향 프로그래밍(AOP : Aspect-Oriented Programming)을 지원

   따라서 트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.

f. 스프링은 영속성과 관련된 다양한 서비스를 지원

   iBatis나 Hibernate 등 이미 완성도가 높은 데이터베이스 처리 라이브러리와 연결할 수 있는 인터페이스를 제공한다.

g. 스프링은 확장성이 높음.

   스프링 프레임워크에 통합하기 위해 간단하게 기존 라이브러리를 감싸는 정도로 스프링에서 사용이 가능하기 때문에 수많은 라이브러리가 

   이미 스프링에서 지원되고 있고 스프링에서 사용되는 라이브러리를 별도로 분리하기도 용이하다.


Spring의 AOP란?


AOP는 Aspect Oriented Programming 관점 지향 프로그래밍의 약자로, 기존의 OOP(객체 지향 프로그래밍)에서 기능별로 class를 분리했음에도 불구하고, 여전히 로그, 트랜잭션, 자원해제, 성능테스트 메서드 처럼 공통적으로 반복되는 중복코드가 여전히 발생하는 단점을 해결하고자 나온 방식으로 이러한 공통 코드를 "횡단 관심사"라 표현하며 개발코드에서는 비지니스 로직에 집중하고 실행시에 비지니스 로직 앞, 뒤 등 원하는 지점에 해당 공통 관심사를 수행할 수 있게 함으로서 중복 코드를 줄일 수 있는 방식입니다.


Spring에서 DI란 무엇인지 아시나요?


DI는 Dependency Injection(의존성 주입)의 약자로, 객체들 간의 의존성을 줄이기 위해 사용되는 Spring의 IOC 컨테이너의 구체적인 구현 방식입니다.

DI는 기존처럼 개발코드 부분에서 객체를 생성하는 것이 아니라, 팩토리 패턴처럼 객체의 생성과, 데이터를 주입만 담당하는 Factory에 해당 하는 별도의 공간에서 객체를 생성하고 데이터간의 의존성을 주입해 개발코드에서는 이를 가져다 씀으로서 의존성을 줄이는 방식입니다. 이때, 

Factory 패턴의 Factory Class의 역할을 스프링의 환경설정 파일이 담당합니다.

 

설정 파일을 통해 객체간의 의존관계를 설정함으로써 외부 Assembler가 객체간의 의존 관계를 정의하게 되며, 객체는 직접 의존하고 있는 객체를 생성하거나 검색할 필요가 없어지므로 코드의 관리가 쉬워진다.


MVC1과 MVC2 패턴의 차이를 설명해 주세요.


Model1(JSP, 자바빈 또는 서비스 클래스)

JSP페이지 내에 로직 처리를 하기 위해 자바 코드가 출력을 위한 코드와 함께 삽입된다. JSP페이지는 요청이 오면 직접 자바빈이나 클래스를 이용하여 작업을 처리하고 처리한 정보를 클라이언트에 출력한다.


장점 : 구조가 단순하다

단점 : 출력을 위한 HTML 코드와 로직 처리를 위한 Java코드가 삽입되어 복잡하고, 유지보수가 어려워진다.


Model2(서플릿, JSP, 자바빈 혹은 서비스 클래스)

모든 처리를 JSP가 담당하는 것이아니라 JSP 페이지와 서블릿 그리고 로직을 위한 클래스가 나뉘어 클라이언트의 요청을 처리한다.


클라이언트에서 요청이 오면 처리할 모델을 클래스 또는 자바 빈이 담당하고 요청결과는 뷰(JSP), 흐름 제어는 Controller인 서블릿이 담당한다.


MVC 패턴이란 Model2 구조를 도입한 구조이며 같은 형태를 가지고 있다.

Model - 서비스 클래스 OR 자바빈

비지니스 로직을 처리하기 위한 모든 것들이 모델에 속한다 EX) 게시판 글쓰기, 가입, 로그인 등 로직을 수행하고 수행 결과를 컨트롤러에 반환한다.


View - JSP

클라이언트에서 출력하는 화면을 말한다.


Controller - 서블릿

MVC 패턴의 모든 흐름제어를 맡는다.

브라우저에서 요청이 들어오면 어떤 요청인지를 분석하고 이 요청을 처리하기 위한 모델을 사용하여 처리한다. 사용한 모델로부터 처리결과를 받으면 추가로 처리하거나 가공해야할 정보가 있다면 처리 후 request 또는 Session 객체에 저장하고 뷰를 선택하여 클라이언트에 출력한다.


장점 : M V C 모델이 나누어 지기 때문에 코드를 분리하여 쉽게 유지보수가용이하다.

뷰, 로직 처리에 대한 분업이 용이하다.

단점 : 구조가 복잡하여 습득이 어렵고 작업량이 많다.


스프링 필터와 인터셉터의 차이 





Filter와 Interceptor는 실행되는 시점이 다르다. 

Filter는 Web Application에 등록을 하고, Interceptor는 Spring의 Context에 등록을 한다.

컨트롤러에 들어가기 전에 작업을 처리하기 위해 사용할 수 있다는 공통점이 있지만 호출되는 시점이 다르다.



1. Filter는 Dispatcher servlet의 앞단에서 정보를 처리하고, Interceptor는 Dispatcher servlet에서 Handler(Controller)로 가기 전에 정보를 처리한다.
2. 또한 필터는 J2EE 표준 스펙에 정의 되어 있는 기능이며, 인터셉터의 경우는 Spring Framework에서 자체적으로 제공하는 기능이라고 한다.

정확히 어떤 상황에 어떤 기능을 사용해야 하는가에 대해서는 갑론을박이 많지만, 인코딩이나 보안 관련 처리와 같은 web app의 전역적으로 처리해야 하는 로직은 필터로 구현하고 클라이언트에서 들어오는 디테일한 처리(인증, 권한 등)에 대해서는 주로 인터셉터에서 처리하는듯 하다



IOC란 무엇인가 



인스턴스 생성의 제어를 개발자 본인이 아닌 다른 누군가에게 반환해 준다는 개념으로 여기서 말하는 다른 누군가는 Servlet과 같은 bean을 관리해주는 컨테이너이다.

즉 IOC란 인스턴스의 생성부터 소멸까지 개발자가 아닌 컨테이너가 대신 관리해준 다는 것이다.


AOP 클래스 참조와 인터페이스 참조 차이점



스프링 부트와 스프링의 차이



스프링 부트는 스프링 프레임워크르 사용하는 프로젝트를 간편하게 셋업할 수 있는 서브 프로젝트이다. 독립 컨테이너에서 동작할 수 있기 때문에 embeded tomcat이 자동으로 실행됩니다. embeded container에서 어플리케이션에서 실행시키기에는 다소 불안전하기 때문에 큰 프로젝트에서는 사용하지 않는 것이 좋다.


Spring MVC 구조의 처리 과정을 설명하라





1. DispatcherServlet : 어플리케이션으로 들어오는 모든 Request를 받는 관문이다. Request를 실제로 처리할 Controller 에게 전달하고 그 결과값을 받아서 View에게 전달하여 적절한 응답등 생성할 수 있도록 흐름을 제어한다.

2. HandlerMapping : Request URL 각각을 어떤 Controller 가 실제로 처리할 것인지 찾아주는 역할을 한다.

3. Controller : Request를 직접 처리한 후 그 결과를 다시 DispatcherServlet 에게 돌려준다.

4. ModelAndView : Controller가 처리한 결과와 그 결과를 보여줄 View에 관한 정보를 담고 있는 객체이다.

5. ViewResolver : View 관련 정보를 갖고 실제 View를 찾아주는 역할을 한다.

6. View : Controller가 처리한 결과값을 보여줄 View를 생성한다.




DAO 와 DTO



DAO

Data Access Object의 약자로 간단히 Database의 data에 접근을 위한 객체입니다. Database에 접근을 하기위한 로직과 비즈니스 로직을 분리하기 위해서 사용을 합니다

DAO(Data Access Object)는 DB를 사용해 데이터를 조화하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.



DTO

DTO(Data Transfer Object)는 VO(Value Object)로 바꿔 말할 수 있는데 계층간 데이터 교환을 위한 자바빈즈를 말합니다.여기서 말하는 계층간의 Controller, View, Business Layer, Persistent Layer를 말하며 각 계층간 데이터 교환을 위한 객체를 DTO 또는 VO라고 부릅니다. 그런데 VO는 DTO와 동일한 개념이지만 read only 속성을 가짐



왜 스프링에서 bean생성시에 타입추론으로 자료형을 비교하냐

A라는 라이브러리는 C라는 인터페이스를 상속받은 자료형의 클래스를 빈에서 땡겨다 쓰기로 이미 약속이 되어있다.

다형성을 이용하여 인터페이스의 자료형을 상속받은 구현 객체의 같은 동작을 보장하기 위해 사용한다.



출처: http://ktko.tistory.com/entry/개발자-면접-질문자바-스프링?category=625364 [KTKO 개발 블로그와 여행 일기]






##########################################################
자바면접 손코딩 문제
##########################################################
유튜브, 책, 구글검색, OKKY 토대로 작성해보았다. 추후 발견할 때마다 업데이트를 할 예정....  신입 또는 경력의 문제가 포함(경력 치고는 너무 쉬운 문제가 있을 수도 있지만 면접시간이 길지 않기 때문에 쉬운 문제로 출제되는 케이스가 있었음)



1. 재귀를 이용한 피보나치(fibo 함수)

2. 메모이제이션을 이용한 피보나치(memoFibo 함수)

3. 재귀를 이용한 팩토리얼 문제(fact 함수)

4. 10번 동안 1~10까지 랜덤한 숫자를 출력하여 중복된 숫자가 있을 경우 true, false를 리턴하라(randomQuiz)

(판교의 어느 대기업 손코딩 문제) 그닥 어렵지 않은 문제 랜덤함수 범위만 지정할 줄 알면 매우 쉬운 것 같다.

int a = (int)(Math.random()*10)+1; //1 ~ 10 랜덤 함수 뽑아내기


1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
public final class CodingExample {
    public static int[]table;
    public static void main(String[] args) {
        table = new int[7+1];
//        System.out.println(fibo(7));
//        System.out.println(memoFibo(7));
//        System.out.println(fact(5));
        
        randomQuiz();
    }
    
    //피보나치 
    public static int fibo(int data) {
        if(data <= 1) {
            return 1;
        }
            
        
        return fibo(data-1) + fibo(data-2);
    }
    
    //피보나치 
    public static int memoFibo(int data) {
        if(data <= 1) {
            table[data] = 1;
            return 1;
        }
        
        if(table[data] > 0) {
            
            return table[data];
        }
            
        table[data] = memoFibo(data-1) + memoFibo(data-2);
        
        return table[data];
    }
    
    //factorial
    public static int fact(int data) {
        if(data <= 1) 
            return 1;
        
        
        return fact(data-1) * data;
    }
    
    //Math.Random();
    public static void randomQuiz() {
        
        for(int i=0; i < 50; i++) {
            
            int randomValue = (int)(Math.random()*10)+1;
            System.out.println(randomValue);
        }
    }
}





5. 각종 정렬

면접 시간에 따라 다르겠지만 짧다면 (삽입, 버블, 선택) 길다면(힙, 퀵, 합병)정렬을 예상한다.

블로그를 참조하면 된다.



6. 각종 자료구조 구현해보기(Stack, Queue, HashTable, LinkedList) 등등

블로그를 참조하면 된다.



7. Anagram

아나그램이란 ? 서로 다른 두 문자열이 있을때 두 문자열의 알파벳을 재배열하였을때 같은 단어 혹은 문장. 

예를 들어, apple과 ppale는 아나그램 abcd와 bacd는 아나그램



1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
public static boolean checkAnagram(String str1, String str2) {
    //공백 제거
    str1 = str1.replaceAll("\\s", "");
    str2 = str2.replaceAll("\\s", "");
 
    //미리 문자열의 길이가 같은지 계산하여 1차적인 결과 수행
    if (str1.length() != str2.length()) {
        return false;
    }
 
    // 두 단어다 소문자로 변환 후 char 형식으로 변환해주는 toCharArray() 메서드 활용
    char[] char1 = str1.toLowerCase().toCharArray();
    char[] char2 = str2.toLowerCase().toCharArray();
 
    // Arrays.sort()를 이용하여 정렬을 한다.
    Arrays.sort(char1);
    Arrays.sort(char2);
 
    // String 비교를 위해 character 배열을 String으로 변환한다.
    String _str1 = new String(char1);
    String _str2 = new String(char2);
 
    // 비교한 결과를 리턴한다.
    return _str1.equals(_str2);
}




8. 문자열 안에 문자들이 고유한 문자인지 확인



주어진 문자열의 문자들이 모두 고유한지를 확인하는 함수를 구현하시오. 





담당자에게 질문해야할 것은 ?



해당 문자열이 아스키인지 유니코드를 포함하는지 확인을 해야한다.아스키일경우 128개의 배열을 사용해야한다. 

Unicode는 2의 20승 + 2의 16승의 1,114,112개의 문자를 가지기 때문에 자바의 HashMap을 구현해야한다.



아스키 코드



1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
public boolean isUnique(String str) {
    if(str.length() > 128) return false;
    boolean[] char_set = new boolean[128];
    
    for(int i=0; i < str.length(); i++) {
        int val = str.charAt(i);            
        if(char_set[val]) {
            
            return false;
        }
        
        char_set[val] = true;
    }
    
    return true;
}




유니코드



1
2
3
4
5
6
7
8
9
10
11
12
13
public boolean isUnique(String str) {
    HashMap<Integer, Boolean> hashMap = new HashMap<Integer, Boolean>();
    for(int i=0; i < str.length(); i++) {
        int ch = str.charAt(i);
        if(hashMap.containsKey(ch)) {
            
            return false;
        }
        
        hashMap.put(ch, true);
    }
    return true;
}





9. 최소공배수 최소공약수 구하기

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
public class CommonNumber {
    static int a, b;
 
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        Scanner scan = new Scanner(System.in);
        a = scan.nextInt();
        b = scan.nextInt();
        if (b > a) {
            int temp = b;
            b = a;
            a = temp;
        }
        int result = gcd(a, b);
        System.out.println(result);
        System.out.println(a * b / result);
    }
 
    public static int gcd(int a, int b) {
        if (a % b == 0)
            return b;
        return gcd(b, a % b);
    }
}



추후 지속적인 업데이트 !!
